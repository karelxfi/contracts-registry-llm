<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>leNFT Smart Contract Addresses - DeFi Registry</title>
  <meta name="description" content="Verified smart contract addresses for leNFT across 0 blockchains. Nft marketplace protocol contracts and ABIs.">
  <link rel="canonical" href="https://karelxfi.github.io/contracts-registry-llm/protocols/lenft" />
  <link rel="stylesheet" href="../styles.css">

  <!-- Structured Data for LLMs and Search Engines -->
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "leNFT",
  "applicationCategory": "Blockchain Protocol",
  "description": "leNFT is a nft marketplace protocol deployed across 0 blockchains.",
  "url": "https://karelxfi.github.io/contracts-registry-llm/protocols/lenft",
  "softwareVersion": "lenft",
  "author": {
    "@type": "Organization",
    "name": "leNFT"
  }
}
  </script>

  <!-- OpenGraph for social sharing and LLM parsing -->
  <meta property="og:title" content="leNFT - Smart Contract Registry" />
  <meta property="og:description" content="0 chains, 0 contracts. nft marketplace protocol." />
  <meta property="og:type" content="website" />

  <!-- Protocol metadata for easy parsing -->
  <meta name="protocol:id" content="lenft" />
  <meta name="protocol:name" content="leNFT" />
  <meta name="protocol:type" content="nft marketplace" />
  <meta name="protocol:chains" content="0" />
  <meta name="protocol:contracts" content="0" />
  <meta name="protocol:status" content="active" />
  <meta name="protocol:defillama_id" content="lenft" />
  
  
  
</head>
<body>
  <nav>
    <div class="nav-container">
      <a href="/" class="logo">DeFi Registry</a>
      <div class="nav-links">
        <a href="/protocols" class="nav-link">Protocols</a>
        <a href="/chains" class="nav-link">Chains</a>
        <a href="/api/v1" class="nav-link">API</a>
        <a href="https://github.com/karelxfi/contracts-registry-llm" class="nav-link">GitHub</a>
      </div>
    </div>
  </nav>

  <!-- Machine-readable data section for LLMs (hidden from users) -->
  <script type="application/json" id="protocol-data" data-protocol-id="lenft">
{
  "id": "lenft",
  "name": "leNFT",
  "type": "nft marketplace",
  "website": "",
  "github": "",
  "docs": "",
  "defillamaId": "lenft",
  "tags": [
    "nft marketplace",
    "ethereum"
  ],
  "contracts": {
    "main": {
      "name": "leNFT Main Contract",
      "type": "core",
      "description": "Main contract for leNFT",
      "proxy": false,
      "keyEvents": [],
      "keyFunctions": [],
      "useCases": []
    }
  },
  "deployments": {
    "ethereum": {
      "chain": "ethereum",
      "addresses": {
        "main": ""
      },
      "deploymentBlocks": {
        "main": null
      },
      "verified": {
        "main": false
      },
      "source": [
        "defillama"
      ],
      "sourceUrl": "https://defillama.com/protocol/lenft",
      "updated": "2025-01-31"
    }
  }
}
  </script>

  <!-- Plain text summary for easy LLM parsing -->
  <div id="llm-summary" style="display: none;" data-purpose="llm-parsing">
    <h1>Protocol: leNFT</h1>
    <p>ID: lenft</p>
    <p>Type: nft marketplace</p>
    <p>Status: active</p>
    <p>Chains: 0</p>
    <p>Total Contracts: 0</p>
    
    
    
    <p>DefiLlama ID: lenft</p>

    <h2>Contract Addresses by Chain:</h2>
    <pre>ethereum:
  - main: </pre>

    <h2>API Endpoint:</h2>
    <p>GET https://karelxfi.github.io/contracts-registry-llm/api/v1/protocol/lenft.json</p>
  </div>

  <div class="protocol-page" itemscope itemtype="https://schema.org/SoftwareApplication">
    <div class="container">
      <div class="breadcrumb">
        <a href="/">Home</a> / <a href="/protocols">Protocols</a> / <span itemprop="name">leNFT</span>
      </div>

      <header class="protocol-hero">
        <div class="protocol-title-row">
          <div class="protocol-title-section">
            <h1 itemprop="name" data-protocol-id="lenft">leNFT</h1>
            <span class="protocol-type-badge" data-type="nft marketplace">nft marketplace</span>
          </div>
          
        </div>
      </header>

      <div class="deployments-section">
        <div class="section-header">
          <div class="section-header-content">
            <h2>Contract Deployments</h2>
            <p class="section-description">Contract deployment information for leNFT is not yet available.</p>
          </div>
          
        </div>

        
          <div class="no-deployments-message">
            <div class="no-deployments-content">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--color-text-tertiary); opacity: 0.5; margin-bottom: 16px;">
                <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              <h3>No Contracts Available Yet</h3>
              <p>Contract deployment information for leNFT is not currently available in our registry.</p>
              
            </div>
          </div>
        </div>
      </div>

      
    </div>
  </div>

  <footer>
    <div class="footer-container">
      <div class="footer-bottom">
        <div>© 2025 DeFi Registry. Open source under MIT License.</div>
        <div><a href="https://github.com/karelxfi/contracts-registry-llm">View on GitHub</a></div>
      </div>
    </div>
  </footer>

  <script>
    let copiedAddress = null;
    let sortState = { column: 'chain', direction: 'asc' };
    let allRows = [];

    // Load deployment data from API
    fetch('../api/v1/protocol/lenft.json')
      .then(res => res.json())
      .then(data => {
        const tbody = document.querySelector('#deploymentsTable tbody');
        if (!tbody) return;

        // Flatten deployments into table rows (no rowspan for better sorting)
        Object.entries(data.deployments || {}).forEach(([chainId, deployment]) => {
          const addresses = Object.entries(deployment.addresses || {});

          addresses.forEach(([contractName, address]) => {
            const row = document.createElement('tr');
            row.setAttribute('data-chain', chainId.toLowerCase());
            row.setAttribute('data-chain-id', String(deployment.chainId || ''));
            row.setAttribute('data-contract-name', contractName.toLowerCase());
            row.setAttribute('data-contract-address', address.toLowerCase());

            // Show chain info on every row for better sorting
            row.innerHTML = `
              <td class="chain-cell">
                ${chainId}
              </td>
              <td class="chain-id-cell">${deployment.chainId || 'N/A'}</td>
              <td class="contract-name-cell">${contractName}</td>
              <td class="address-cell">
                <div class="address-with-copy">
                  <code>${address}</code>
                  <button class="copy-btn-inline" onclick="copyAddress('${address}', this)" title="Copy address">
                    <svg class="copy-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <svg class="check-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"></path>
                    </svg>
                  </button>
                </div>
              </td>
              <td class="source-cell">
                ${deployment.sourceUrl ? `<a href="${deployment.sourceUrl}" class="source-link-small" target="_blank" rel="noopener">View Source ↗</a>` : '<span class="no-source">—</span>'}
              </td>
            `;

            tbody.appendChild(row);
            allRows.push(row);
          });
        });

        // After loading, update stats and initialize features
        updateFilterStats();
        updateLLMSummary(data);
        initTableSort();
        initTableFilter();
      })
      .catch(err => console.error('Failed to load deployments:', err));

    // Update the hidden LLM summary section with full contract data
    function updateLLMSummary(data) {
      const summaryDiv = document.getElementById('llm-summary');
      if (!summaryDiv) return;

      const contractsList = Object.entries(data.deployments || {}).map(([chain, deployment]) => {
        const addresses = Object.entries(deployment.addresses || {})
          .map(([name, address]) => `  - ${name}: ${address}`)
          .join('\n');
        return `${chain}:\n${addresses}`;
      }).join('\n\n');

      const contractsSection = summaryDiv.querySelector('pre');
      if (contractsSection) {
        contractsSection.textContent = contractsList;
      }
    }

    // Copy to clipboard function with visual feedback
    function copyAddress(text, button) {
      // Try modern clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text)
          .then(() => {
            showCopyFeedback(button);
          })
          .catch(err => {
            console.error('Clipboard API failed:', err);
            fallbackCopy(text, button);
          });
      } else {
        // Fallback for older browsers or non-secure contexts
        fallbackCopy(text, button);
      }
    }

    function showCopyFeedback(button) {
      const copyIcon = button.querySelector('.copy-icon');
      const checkIcon = button.querySelector('.check-icon');

      if (copyIcon && checkIcon) {
        copyIcon.style.display = 'none';
        checkIcon.style.display = 'block';
        button.classList.add('copied');

        setTimeout(() => {
          copyIcon.style.display = 'block';
          checkIcon.style.display = 'none';
          button.classList.remove('copied');
        }, 2000);
      }
    }

    function fallbackCopy(text, button) {
      // Create temporary textarea
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.top = '-9999px';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);

      try {
        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile devices

        const successful = document.execCommand('copy');
        if (successful) {
          showCopyFeedback(button);
        } else {
          throw new Error('execCommand failed');
        }
      } catch (err) {
        console.error('Fallback copy failed:', err);
        // Show address in alert as last resort
        prompt('Copy this address:', text);
      } finally {
        document.body.removeChild(textarea);
      }
    }

    // Keep old function for API section compatibility
    function copyToClipboard(text) {
      const btn = event.target;
      const originalText = btn.textContent;

      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          btn.textContent = '✓ Copied!';
          btn.style.background = '#00d084';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
          }, 2000);
        }).catch(err => {
          console.error('Clipboard API failed:', err);
        });
      }
    }

    // Filter table functionality
    function initTableFilter() {
      const filterInput = document.getElementById('tableFilter');
      if (!filterInput) return;

      filterInput.addEventListener('input', (e) => {
        const filterValue = e.target.value.toLowerCase().trim();
        filterTable(filterValue);
      });
    }

    function filterTable(filterValue) {
      const tbody = document.querySelector('#deploymentsTable tbody');
      const noResults = document.getElementById('noResults');
      if (!tbody) return;

      let visibleCount = 0;

      allRows.forEach(row => {
        const chain = row.getAttribute('data-chain') || '';
        const chainId = row.getAttribute('data-chain-id') || '';
        const contractName = row.getAttribute('data-contract-name') || '';
        const address = row.getAttribute('data-contract-address') || '';

        const matches = filterValue === '' ||
          chain.includes(filterValue) ||
          chainId.includes(filterValue) ||
          contractName.includes(filterValue) ||
          address.includes(filterValue);

        if (matches) {
          row.style.display = '';
          visibleCount++;
        } else {
          row.style.display = 'none';
        }
      });

      // Show/hide no results message
      if (noResults) {
        if (visibleCount === 0 && filterValue !== '') {
          noResults.style.display = 'flex';
          tbody.style.display = 'none';
        } else {
          noResults.style.display = 'none';
          tbody.style.display = '';
        }
      }

      updateFilterStats(visibleCount);
    }

    function updateFilterStats(visibleCount) {
      const visibleEl = document.getElementById('visibleRows');
      const totalEl = document.getElementById('totalRows');

      if (visibleEl && totalEl) {
        const visible = visibleCount !== undefined ? visibleCount : allRows.length;
        visibleEl.textContent = visible;
        totalEl.textContent = allRows.length;
      }
    }

    // Add table sorting functionality
    function initTableSort() {
      const table = document.getElementById('deploymentsTable');
      if (!table) return;

      const headers = table.querySelectorAll('th');
      const tbody = table.querySelector('tbody');

      headers.forEach((header, index) => {
        const column = header.getAttribute('data-column');
        if (!column) return; // Skip headers without data-column (like Source)

        header.addEventListener('click', () => {
          const currentDirection = sortState.column === column && sortState.direction === 'asc' ? 'desc' : 'asc';
          sortState.column = column;
          sortState.direction = currentDirection;

          // Sort the rows
          sortTable(column, currentDirection);

          // Update sort indicators
          headers.forEach(h => {
            const indicator = h.querySelector('.sort-indicator');
            if (indicator) {
              indicator.textContent = '';
              indicator.className = 'sort-indicator';
            }
          });

          const indicator = header.querySelector('.sort-indicator');
          if (indicator) {
            indicator.textContent = currentDirection === 'asc' ? ' ↑' : ' ↓';
            indicator.className = 'sort-indicator active';
          }
        });
      });

      // Initial sort by chain name
      sortTable('chain', 'asc');
    }

    function sortTable(column, direction) {
      const tbody = document.querySelector('#deploymentsTable tbody');
      if (!tbody) return;

      const rows = Array.from(allRows);

      rows.sort((a, b) => {
        let aVal, bVal;

        switch (column) {
          case 'chain':
            aVal = a.getAttribute('data-chain') || '';
            bVal = b.getAttribute('data-chain') || '';
            break;
          case 'chainId':
            aVal = parseInt(a.getAttribute('data-chain-id')) || 0;
            bVal = parseInt(b.getAttribute('data-chain-id')) || 0;
            break;
          case 'contractName':
            aVal = a.getAttribute('data-contract-name') || '';
            bVal = b.getAttribute('data-contract-name') || '';
            break;
          case 'address':
            aVal = a.getAttribute('data-contract-address') || '';
            bVal = b.getAttribute('data-contract-address') || '';
            break;
          default:
            return 0;
        }

        // Numeric comparison for chain IDs
        if (column === 'chainId') {
          return direction === 'asc' ? aVal - bVal : bVal - aVal;
        }

        // String comparison
        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
      });

      // Clear and re-append rows in sorted order
      tbody.innerHTML = '';
      rows.forEach(row => tbody.appendChild(row));
    }

    // Initialize sorting after data loads
    document.addEventListener('DOMContentLoaded', initTableSort);
  </script>
</body>
</html>